# 피보나치 수열 단순 재귀 코드
# 피보나치 수열의 점화식은 트리로 나타낼 수 있음
def fibo(x):
    if x==1 or x==2:
        return 1
    return fibo(x-1)+fibo(x-2)

# 피보나치 수열은 단순재귀 함수로 해결하면 지수 시간 복잡도를 가짐
# 즉 f(2)가 여러번 호출 => 중복되는 부분 문제

# 다이나믹 프로그래밍을 이용하면 효율적 해결 가능

# 구현방법
# 1. 탑다운(메모이제이션) = 하향식
# : 구현 과정에서 재귀함수 사용. 큰 문제를 해결하기 위해 작은 문제들을 재귀적으로 호출 
#   작은 문제들이 모두 해결되엇을때 큰 문제에 대한 값까지 얻도록 함
# 2. 보텀업 = 상향식 @@ 전형적인 방식. 
# : 아래쪽에서 부터 작은 문제를 하나씩 해결하면서 올라감. 먼저 해결했던 값들을 활용해서 다음 값 구하는데 사용
# !! 이때 사용하는 결과 저장용 리스트는 DP테이블이라고 부름

# 메모이제이션 : 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
# 엄연히 말하면 이전 계산된 결과를 일시적으로 기록해놓는 넓은 개념을 의미. 다이나믹 프로그래밍에 국한된 개념은 아님

# 피보나치 수열의 탑다운 다이나믹 프로그래밍----------------------------------------------------------
d =[0]*100

def fibo_top(x):
    print('f('+str(x)+')', end='')
    if x==1 or x==2:
        return 1
    #!!! 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x]!=0:
        return d[x]
    # 아직 계산하지 않은 문제라면 피보나치 결과 반환
    d[x]= fibo_top(x-1)+fibo_top(x-2)
    return d[x]

fibo_top(6)
# 피보나치 수열의 보텀업 다이나믹 프로그래밍--------------------------------------------------------
# 반복문을 사용하고 초기값을 정해줌
d =[0]*100
d[1]=1
d[2]=1
n=99

for i in range(3,n+1):
    d[i]=d[i-1]+d[i-2]
print()

print(d[n])

#=======================================================================================

# 분할정복 VS 다이나믹 프로그래밍 (부분문제 중복의 유무가 차이)
# 분할정복의 경우 예로 퀵정렬을 보면 기준원소(pivot)이 자리 잡으면 그 기준 원소 위치는 바뀌지X
# 다이나믹 프로그래밍에선 각 부분문제들이 서로 영향을 미치며 부분 문제가 중복

# ??? 접근 방법 ???
# 가장 먼저 그리디, 구현, 완전탐색 등의 아이디어로 문제 해결 가능한지 검토 => 안떠오를 경우 DP 고려
# 일단 재귀 함수로 비효율적인 완전 탐색 프로그램 (탑다운) 작성 후 
#    작은 문제에서 구한 답이 큰 문제에서 그대로 사용 가능하다면 코드 개선하는 방법 사용 (메모이제이션 기법 추가)
# 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제 출제 되는 경우 많음

#======================================================================================
# 개미 전사 문제

n=int(input())

array=list(map(int, input().split()))

d=[0]*100 # 앞서 계산된 결과 저장하기 위한 DP 테이블
d[0]=array[0]
d[1]=max(array[0],array[1])
# 첫번째 두번째 항 구한 후 이들 이용하여 보텀업 방식 실행

for i in range(2,n):
    d[i]=max(d[i-1], d[i-2]+array[i])

print(d[n-1])
#=====================================================================================
# 1로 만들기 문제
# 단순한 그리디로는 해결 힘듦. 연산을 조합하면 다른 횟수들이 나오므로 부분문제들을 조합해서 사용할 것

x=int(input())
d=[0]*3001
 # 1의 경우 자기 자신은 연산 필요없으므로 0으로 세팅

for i in range(2,x+1): # 다이나믹 프로그래밍 (보텀업)실행
   
    # 나누기 연산 안될 경우 구하는 방법
    d[i]=d[i-1]+1

    if i%2==0:
        d[i]=min(d[i],d[i//2]+1)
    if i%3==0:
        d[i]=min(d[i],d[i//3]+1)
    if i%5==0:
        d[i]=min(d[i],d[i//5]+1)

print(d[x])
#=====================================================================================
# 효율적인 화폐 구성

n,m=map(int, input().split())
array=[]
for i in range(n):
    array.append(int(input()))

d=[10001]*(m+1)  # 한 번 계산된 결과를 위한 DP 테이블 조회
d[0]=0           # 보텀업 다이나믹 프로그래밍

# i는 각각의 화폐 단위를 의미, j는 각각의 금액을 확인함
for i in range(n):
    for j in range(array[i], m+1): 
        if(d[j-array[i]]!=10001):   # (i-k)원을 만드는 방법 존재하는 경우
            d[j]=min(d[j],d[j-array[i]]+1)

if d[m]==10001:
    print(-1)
else:
    print(d[m])

#=====================================================================================
# 금광 문제

# 테스트 케이스 입력
for tc in range(int(input)):
    n,m=map(int, input().split())
    array=list(map(int, input().split()))
   
    dp=[] # 다이나믹 프로그래밍 위한 2차원 DP테이블 초기화
    index=0
    for i in range(n):
        # 금광정보가 한줄에 이어져 입력되기 때문에 열에 크기로 데이터 슬라이싱해서 dp 테이블에 담아줌
        dp.append(array[index:index+m]) 
        index+=m
    
    for j in range(1,m): # 다이나믹 프로그래밍 진행 (j)즉 열기준으로 확인
        for i in range(n):
            # if는 인덱스를 벗어나는 경우
            if i==0:
                left_up=0
            else:
                left_up=dp[i-1][j-1]
            if i==n:
                left_down=0
            else:
                left_down=dp[i+1][j-1]

            left=dp[i][j-1]
            dp[i][j]=dp[i][j]+max(left_up, left_down, left)
    result=0

    for i in range(n):
        result=max(result, dp[i][m-1])
    print(result)